=== Smart HTTP

(((serving repositories, HTTP)))
Agora temos acesso autenticado através de SSH e acesso não autenticado através de `git://`, mas existe um protocolo que pode fazer os dois ao mesmo tempo.
Configurar Smart HTTP consiste basicamente em habilitar um script em CGI que é fornecido com Git, chamado `git-http-backend` no servidor.
Esse CGI irá ler o caminho e os cabeçalhos enviados pelo comando `git fetch` ou `git push` para uma URL HTTP e determinar se o cliente pode se comunicar via HTTP (que é válido para qualquer clientea partir da versão 1.6.6).
Se o CGI ver que o cliente é inteligente, ele continuará a se comunicar inteligentemente com ele, caso contrário vai recorrer ao comportamento padrão (então é compatível para leituras com clientes antigos).

Vamos analisar uma configuração bem básica.
Vamos configurar isso com o Apache como servidor CGI.
Se você não tiver Apache configurado, você pode fazer isso em um sistema linux com algo como isso:(((Apache)))

[source,console]
----
$ sudo apt-get install apache2 apache2-utils
$ a2enmod cgi alias env rewrite
----

Isso também habilita os módulos `mod_cgi`, `mod_alias`, `mod_env` e `mod_rewrite`, que são todos necessários para que isso funcione corretamente.

Você também precisa definir o grupo de usuários Unix dos diretórios `/srv/git` para `www-data` para que seu servidor web possa ler e ter acesso de leitura aos repositórios, pois a instância do Apache que executa o CGI estará (por padrão) executando isso como esse usuário:

[source,console]
----
$ chgrp -R www-data /srv/git
----

Em seguida, nós precisamos adicionar algumas coisas a configuração do Apache para executar o `git-http-backend` como o gerenciador de tudo que chegar para o gaminho `/git` de seu servidor web.

[source,console]
----
SetEnv GIT_PROJECT_ROOT /srv/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/lib/git-core/git-http-backend/
----

Se você omitir a variável de ambiente `GIT_HTTP_EXPORT_ALL`, então o Git irá servir aos clientes não autenticados os repositórios com um arquivo `git-daemon-export-ok`, assim como o serviço Git fez.

Por fim, você precisa instruir ao Apache para permitir requisições para o `git-http-backend` e fazer as escritas serem autenticadas de alguma forma, possivelmente com um bloco de autenticação como esse:

[source,console]
----
RewriteEngine On
RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]
RewriteCond %{REQUEST_URI} /git-receive-pack$
RewriteRule ^/git/ - [E=AUTHREQUIRED]

<Files "git-http-backend">
    AuthType Basic
    AuthName "Git Access"
    AuthUserFile /srv/git/.htpasswd
    Require valid-user
    Order deny,allow
    Deny from env=AUTHREQUIRED
    Satisfy any
</Files>
----

Isso exigirá que você crie um arquivo `.htpaswd` contendo as senhas de todos os seus usuários válidos.
Aqui está um exemplo de como adicionar um usuário ``shacon'' no arquivo:

[source,console]
----
$ htpasswd -c /srv/git/.htpasswd schacon
----

Há diversas maneiras de fazer o Apache autenticar usuários, você tem que escolher e implementar uma delas.
Esse é apenas o exemplo mais simples que nós preparamos.
Você provavelmente vai querer configurar isso sobre SSL então todos os dados serão criptografados.

Não queremos ir tão longe nessa toca de coelho de configurações específicas de Apache, já que você pode muito bem estar usando um servidor diferente que tenha diferentes necessidades de autenticação.
A ideia é que o Git vem com um CGI chamado `git-http-backend` que quando é chamado faz toda a negociação para enviar e receber dados via HTTP
Isso não implementa autenticação por si só, mas pode facilmente ser controlado por uma camada do servidor web que faz isso.
Você pode fazer isso com qualquer servidor capaz de executar CGI, então utilize um que você conheça melhor.

[NOTE]
====
Para mais informações de como configurar autenticação no Apache, veja a documentação do Apache aqui:
http://httpd.apache.org/docs/current/howto/auth.html[]
====
